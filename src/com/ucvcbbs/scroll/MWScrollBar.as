package com.ucvcbbs.scroll{	import com.ucvcbbs.events.ScrollEvent;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.geom.Rectangle;	import flash.events.Event;	import flash.utils.getTimer;	import com.greensock.easing.Quad;	import mx.effects.easing.Quartic;	import flash.display.DisplayObjectContainer;	/**	 * 滚动条主类	 * 移动版 滚动条 横向滚动条	 * ...	 * @author ScrollIndicator  by Ray	 */	public class MWScrollBar extends ScrollIndicator	{				/**		 * The difference between the scrollIndicator.height and _height.		 */		private var totalScrollAmount:Number;		/**		 * 头部间距		 */		private var scrollIndicatorLeftPadding:Number;		/**		 * 底部间距		 */		private var scrollIndicatorRightPadding:Number;			/**		 * The target scroll value when a user flicks.		 */		private var targetScrollX:Number;		//		private var itemYOffsetBottom:Number = 0;			    private var scrollIndicator:ScrollSkin;				//		private var backgroundColor:Number;				private var resetScrollX:Boolean = false;				//		private var maxScroll:Number;		private var scrollIndicatorWidth:Number;		//拖拽的y		private var previousDragMouseX:Number;		private var mouseXDown:Number;				private var deltaMouseX:Number = 0;		//初始化时间		private var previousDragTime:uint;		/**		 * The scrollY when a user first starts to drag.		 */		private var beginDragScrollX:Number;		private var enterFrameIndex:Number = 0;		//		private var isDragging:Boolean = false;		/**		 * Flag for whether or not the flick tween is still playing.		 */		private var isTweening:Boolean;		/**		 * The start scroll value when a user flicks.		 */		private var startScrollX:Number;		/**		 * The total amount to scroll when a user flicks.		 */		private var totalScrollX:Number;		/**		 * Properties for tweening a user flick.		 */		private var tweenCurrentCount:Number;		private var tweenTotalCount:Number;						/**		 * MWScrollBar 移动版 横向滚动条		 * view			滚动的对象		 * backgroundColor   背景颜色		 * scrollIndicatorLeftPadding  左边间距		 * scrollIndicatorRightPadding	 右边间距		 * ...		 * @author		 */		public function MWScrollBar(									view:DisplayObjectContainer,									backgroundColor:Number = 0xffffff,									scrollIndicatorLeftPadding:Number=0,									scrollIndicatorRightPadding:Number=0)		{			if (view && view.name != MWHScrollBar.SCROLLBARNAME) {				viewContainer.addChild(view);			}			else {				MWHScrollBarBOOL = true;				viewContainer = view as Sprite;			}						if (!scrollIndicator)			{				scrollIndicator = new ScrollSkin("W");				addChild(scrollIndicator);				scrollIndicatorVisible = false;			}			//			this.backgroundColor = backgroundColor;			this.scrollIndicatorLeftPadding = scrollIndicatorLeftPadding;			this.scrollIndicatorRightPadding = scrollIndicatorRightPadding;		}				public function refreshView(vole:Boolean):void		{			if (stage)			stage.removeEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_W);						resetScrollX = vole;						this.updateX(width, height);						resetScrollX = false;						viewContainer.mouseChildren = viewContainer.mouseEnabled = true;						this.dispatchEvent(new ScrollEvent(ScrollEvent.SCROLLBARUPDATE));		}				//		private function updateX(width:Number, height:Number):void		{			stopTween();						updateMaxScroll();						if (resetScrollX || !viewContainer.scrollRect)			{				viewContainer.scrollRect = new Rectangle(0, 0, width, height);			}			else			{				//当前拖动到的y				scrollX = Math.min(maxScroll, scrollX);				viewContainer.scrollRect = new Rectangle(scrollX, 0, width, height);			}						if (!MWHScrollBarBOOL)			{				graphics.clear();				graphics.beginFill(backgroundColor,0);				graphics.drawRect(0, 0, width, height);			}		}		/**		 * Stops the flick tween.		 */		private function stopTween():void		{			if (isTweening)			{				scrollX = targetScrollX;								if (stage)					stage.removeEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_W);								scrollIndicatorVisible = false;			}		}				private function updateMaxScroll():void		{			if (viewContainer.getChildAt(0).width > 0)			{				maxScroll = Math.round(viewContainer.getChildAt(0).width - width) + itemYOffsetBottom;				//trace("W",maxScroll);				if (maxScroll > 0)				{					var availableWidth:Number = width - scrollIndicatorLeftPadding - scrollIndicatorRightPadding;					////trace(availableWidth);					scrollIndicatorWidth = Math.max(Math.round((availableWidth / viewContainer.getChildAt(0).width) * availableWidth), MIN_SCROLL_INDICATOR_HEIGHT);					////trace(viewContainer.height,scrollIndicatorWidth);					scrollIndicator.width = scrollIndicatorWidth;										scrollIndicator.x = scrollIndicatorLeftPadding;					scrollIndicator.y = height - scrollIndicator.HEIGHT - scrollIndicatorLeftPadding;					totalScrollAmount = availableWidth - scrollIndicatorWidth;									}				else				{					maxScroll = 0;				}			}		}						override protected function mouseDownHandler(evt:MouseEvent):void 		{			//super.mouseDownHandler(evt);						mouseXDown = previousDragMouseX = root.mouseX;						if (maxScroll.toString() == "NaN")			{				updateMaxScroll();			}						////trace(maxScroll);			if (maxScroll > 0)			{				isDragging = false;				stage.removeEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_W);								deltaMouseX = 0;				previousDragTime = getTimer();				//复制最后的y   = 当前拖动到的y				beginDragScrollX = scrollX;								enterFrameIndex = 0;			}					// Listen for a mouseMove first to detect the initial direction			// and when to start dragging.			stage.addEventListener(MouseEvent.MOUSE_MOVE, detectDirection_mouseMoveHandler_W);			stage.addEventListener(MouseEvent.MOUSE_UP, drag_mouseUpHandler_W);		}						private function tween_enterFrameHandler_W(e:Event):void		{			scrollX = Math.round(Quartic.easeOut(tweenCurrentCount, startScrollX, totalScrollX, tweenTotalCount));			tweenCurrentCount += 1;						updateScrollIndicator();						this.dispatchEvent(new ScrollEvent(ScrollEvent.SCROLLBARUPDATE));			if (scrollX == targetScrollX)			{				stage.removeEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_W);				isTweening = false;				addEventListener(Event.ENTER_FRAME, scrollIndicatorFade_enterFrameHandler);							}		}				private function drag_mouseUpHandler_W(e:MouseEvent):void		{			//						if (stage)			{				stage.removeEventListener(MouseEvent.MOUSE_MOVE, detectDirection_mouseMoveHandler_W);				stage.removeEventListener(Event.ENTER_FRAME, drag_enterFrameHandler_W);				stage.removeEventListener(MouseEvent.MOUSE_UP, drag_mouseUpHandler_W);			}						isTweening = false;						if (maxScroll > 0)			{				var elapsedMiliseconds:Number = getTimer() - previousDragTime;				var pixelsPerMillisecond:Number = deltaMouseX / elapsedMiliseconds;				targetScrollX = Math.round(-pixelsPerMillisecond * MAX_PIXEL_MOVE + scrollX);								if (targetScrollX >= 0) // Scrolling up.					targetScrollX = Math.min(maxScroll, targetScrollX);				else			  // Scrolling down.					targetScrollX = Math.max(targetScrollX, 0);									targetScrollX = Math.round(targetScrollX);								var isFlick:Boolean = true;								if (targetScrollX != scrollX && isFlick)				{					doTween(targetScrollX);				}				else				{					// No flick so fade out scrollIndicator immediately.					addEventListener(Event.ENTER_FRAME, scrollIndicatorFade_enterFrameHandler);										/*if (isDragging)						dispatchEvent(new TweenEvent(TweenEvent.TWEEN_COMPLETE));*/				}			}		}		/**		 * The amount to tween is the amount itemContainer.scrollRect.y will change.		 */		private function doTween(value:Number):void		{			targetScrollX = Math.round(value);						startScrollX = scrollX;			totalScrollX = targetScrollX - startScrollX;						tweenCurrentCount = 0;			tweenTotalCount = Math.round(ANIMATION_DURATION * stage.frameRate);			stage.addEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_W);						isTweening = true;		}				private function detectDirection_mouseMoveHandler_W(e:Event):void		{			//trace("W",maxScroll,Math.abs(mouseXDown - root.mouseX),START_TO_DRAG_THRESHOLD);			////trace(maxScroll, Math.abs(mouseXDown - root.mouseY), START_TO_DRAG_THRESHOLD);			if (maxScroll > 0 && Math.abs(mouseXDown - root.mouseX) > START_TO_DRAG_THRESHOLD)			{  				viewContainer.mouseChildren = viewContainer.mouseEnabled = false;												isDragging = true;								stage.removeEventListener(MouseEvent.MOUSE_MOVE, detectDirection_mouseMoveHandler_W);				stage.addEventListener(Event.ENTER_FRAME, drag_enterFrameHandler_W);								//dispatchEvent(new ScrollEvent(ScrollEvent.START_SCROLL, false, false, mouseXDown > root.mouseY ? ScrollEvent.DIRECTION_UP : ScrollEvent.DIRECTION_DOWN));			}		}						/**		 * 影藏滚动条		 */		private function scrollIndicatorFade_enterFrameHandler(e:Event):void		{			scrollIndicator.alpha -= scrollIndicatorAlphaDelta;			if (scrollIndicator.alpha <= 0) {				viewContainer.mouseChildren = viewContainer.mouseEnabled = true;				removeEventListener(Event.ENTER_FRAME, scrollIndicatorFade_enterFrameHandler);								this.dispatchEvent(new ScrollEvent(ScrollEvent.SCROLLBARCOMPLETE));			}		}				private function set scrollIndicatorVisible(value:Boolean):void		{			if (scrollIndicator)			{				removeEventListener(Event.ENTER_FRAME, scrollIndicatorFade_enterFrameHandler);				scrollIndicator.alpha = value ? 1 : 0;			}		}				private function drag_enterFrameHandler_W(e:Event):void		{			if(!MWHScrollBarBOOL)e.stopImmediatePropagation();			if (stage)			{				var newY:Number = beginDragScrollX + (mouseXDown - root.mouseX);								scrollX = newY;				scrollX = scrollX < -(width * .5)?-(width * .5):scrollX > maxScroll+width * .5?maxScroll+width * .5:scrollX;								enterFrameIndex += 1;							if (enterFrameIndex % NUM_FRAMES_TO_MEASURE_SPEED)				{					deltaMouseX = root.mouseX - previousDragMouseX;					previousDragTime = getTimer();					previousDragMouseX = root.mouseX;				}								updateScrollIndicator();								scrollIndicatorVisible = true;			}		}		private function updateScrollIndicator():void		{			var delta:Number = scrollX / maxScroll;			var newWidth:Number;			if (delta < 0)			{				scrollIndicator.x = Math.round(scrollIndicatorLeftPadding);								newWidth = scrollX + scrollIndicatorWidth;				newWidth = Math.max(MIN_SCROLL_INDICATOR_HEIGHT, newWidth);				scrollIndicator.width = Math.round(newWidth);			}			else if (delta < 1)			{				if (scrollIndicator.width != scrollIndicatorWidth)					scrollIndicator.width = Math.round(scrollIndicatorWidth);								var newY:Number = Math.round(delta * totalScrollAmount);				newY = Math.min(_width - scrollIndicatorWidth - scrollIndicatorRightPadding, newY);				scrollIndicator.x = Math.round(newY + scrollIndicatorLeftPadding);			}			else	// User dragged above the bottom edge.			{				// Shrink scrollIndicator.height by the amount a user has scrolled above the bottom edge.				newWidth = scrollIndicatorWidth - (scrollX - maxScroll);				newWidth = Math.max(MIN_SCROLL_INDICATOR_WIDTH, newWidth);				scrollIndicator.width = Math.round(newWidth);				scrollIndicator.x = Math.round(_width - newWidth - scrollIndicatorRightPadding);			}			this.dispatchEvent(new ScrollEvent(ScrollEvent.SCROLLBARUPDATE));		}				///////////////////		override public function removeAt():void 		{			if (stage)			{				stage.removeEventListener(Event.ENTER_FRAME, drag_enterFrameHandler_W);				stage.removeEventListener(MouseEvent.MOUSE_UP, drag_mouseUpHandler_W);				stage.removeEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_W);				removeEventListener(Event.ENTER_FRAME, scrollIndicatorFade_enterFrameHandler);				stage.removeEventListener(MouseEvent.MOUSE_MOVE, detectDirection_mouseMoveHandler_W);			}			super.removeAt();					}			}}