package com.ucvcbbs.scroll{	import com.ucvcbbs.events.ScrollEvent;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.geom.Rectangle;	import flash.events.Event;	import flash.utils.getTimer;		import com.greensock.easing.Quad;	import mx.effects.easing.Quartic;	import flash.display.DisplayObjectContainer;	/**	 * 滚动条主类	 * 移动版 滚动条 竖向滚动条	 * ...	 * @author ScrollIndicator  by Ray	 */	public class MHScrollBar extends ScrollIndicator	{				/**		 * The difference between the scrollIndicator.height and _height.		 */		private var totalScrollAmount:Number;		/**		 * 头部间距		 */		private var scrollIndicatorTopPadding:Number;		/**		 * 底部间距		 */		private var scrollIndicatorBottomPadding:Number;			/**		 * The target scroll value when a user flicks.		 */		private var targetScrollY:Number;		//		private var itemYOffsetBottom:Number = 0;			    private var scrollIndicator:ScrollSkin;				//		private var backgroundColor:Number;				private var resetScrollY:Boolean = false;				//		private var maxScroll:Number;		private var scrollIndicatorHeight:Number;		//拖拽的y		private var previousDragMouseY:Number;		private var mouseYDown:Number;				private var deltaMouseY:Number = 0;		//初始化时间		private var previousDragTime:uint;		/**		 * The scrollY when a user first starts to drag.		 */		private var beginDragScrollY:Number;		private var enterFrameIndex:Number = 0;		//		private var isDragging:Boolean = false;		/**		 * Flag for whether or not the flick tween is still playing.		 */		private var isTweening:Boolean;		/**		 * The start scroll value when a user flicks.		 */		private var startScrollY:Number;		/**		 * The total amount to scroll when a user flicks.		 */		private var totalScrollY:Number;		/**		 * Properties for tweening a user flick.		 */		private var tweenCurrentCount:Number;		private var tweenTotalCount:Number;				/**		 * MHScrollBar 移动版 竖向滚动条		 * view			滚动的对象		 * backgroundColor   背景颜色		 * scrollIndicatorTopPadding  头部间距		 * scrollIndicatorBottomPadding	 底部间距		 * ...		 * @author		 */		public function MHScrollBar(									view:DisplayObjectContainer,									backgroundColor:Number = 0xffffff,									scrollIndicatorTopPadding:Number=0,									scrollIndicatorBottomPadding:Number=0)		{			if (view && view.name != MWHScrollBar.SCROLLBARNAME) {				viewContainer.addChild(view);			}			else {				MWHScrollBarBOOL = true;				viewContainer = view as Sprite;			}						if (!scrollIndicator)			{				scrollIndicator = new ScrollSkin("H");				addChild(scrollIndicator);				scrollIndicatorVisible = false;			}			//			this.backgroundColor = backgroundColor;			this.scrollIndicatorTopPadding = scrollIndicatorTopPadding;			this.scrollIndicatorBottomPadding = scrollIndicatorBottomPadding;		}				public function refreshView(vole:Boolean):void		{			if (stage)			stage.removeEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_Y);						resetScrollY = vole;						this.updateX(width, height);						resetScrollY = false;						viewContainer.mouseChildren = viewContainer.mouseEnabled = true;						this.dispatchEvent(new ScrollEvent(ScrollEvent.SCROLLBARUPDATE));		}				//		private function updateX(width:Number, height:Number):void		{			stopTween();						//trace(width, height);			updateMaxScroll();			//trace(width, height);						if (resetScrollY || !viewContainer.scrollRect)			{				viewContainer.scrollRect = new Rectangle(0, 0, width, height);			}			else			{				//当前拖动到的y				scrollY = Math.min(maxScroll, scrollY);				viewContainer.scrollRect = new Rectangle(0, scrollY, width, height);			}						if (!MWHScrollBarBOOL)			{				graphics.clear();				graphics.beginFill(backgroundColor,0);				graphics.drawRect(0, 0, width, height);			}		}		/**		 * Stops the flick tween.		 */		private function stopTween():void		{			if (isTweening)			{				scrollY = targetScrollY;								if (stage)					stage.removeEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_Y);								scrollIndicatorVisible = false;			}		}				private function updateMaxScroll():void		{						if (viewContainer.getChildAt(0).height > 0)			{				maxScroll = Math.round(viewContainer.getChildAt(0).height - height) + itemYOffsetBottom;				//trace("H",maxScroll);				if (maxScroll > 0)				{					var availableHeight:Number = height - scrollIndicatorTopPadding - scrollIndicatorBottomPadding;					////trace(availableHeight);					scrollIndicatorHeight = Math.max(Math.round((availableHeight / viewContainer.getChildAt(0).height) * availableHeight), MIN_SCROLL_INDICATOR_HEIGHT);					////trace(viewContainer.height,scrollIndicatorHeight);					scrollIndicator.height = scrollIndicatorHeight;					scrollIndicator.x = width - scrollIndicator.WIDTH - scrollIndicatorTopPadding;					scrollIndicator.y = scrollIndicatorTopPadding;					totalScrollAmount = availableHeight - scrollIndicatorHeight;				}				else				{					maxScroll = 0;				}			}		}						override protected function mouseDownHandler(evt:MouseEvent):void 		{			//super.mouseDownHandler(evt);			mouseYDown = previousDragMouseY = root.mouseY;						if (maxScroll.toString() == "NaN")			{				updateMaxScroll();			}			if (maxScroll > 0)			{				isDragging = false;				stage.removeEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_Y);								deltaMouseY = 0;				previousDragTime = getTimer();				//复制最后的y   = 当前拖动到的y				beginDragScrollY = scrollY;								enterFrameIndex = 0;			}					// Listen for a mouseMove first to detect the initial direction			// and when to start dragging.			stage.addEventListener(MouseEvent.MOUSE_MOVE, detectDirection_mouseMoveHandler_Y);			stage.addEventListener(MouseEvent.MOUSE_UP, drag_mouseUpHandler_Y);		}						private function tween_enterFrameHandler_Y(e:Event):void		{			scrollY = Math.round(Quartic.easeOut(tweenCurrentCount, startScrollY, totalScrollY, tweenTotalCount));			//trace(scrollY);						tweenCurrentCount += 1;						//刷新滚动条			updateScrollIndicator();						this.dispatchEvent(new ScrollEvent(ScrollEvent.SCROLLBARUPDATE));			//trace(scrollY, targetScrollY);			if (scrollY == targetScrollY)			{				stage.removeEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_Y);				isTweening = false;				addEventListener(Event.ENTER_FRAME, scrollIndicatorFade_enterFrameHandler);				//				dispatchEvent(new ScrollEvent(ScrollEvent.COMPLETE));				//viewContainer.mouseChildren = viewContainer.mouseEnabled = true;			}		}				private function drag_mouseUpHandler_Y(e:MouseEvent):void		{			//			if (stage)			{				stage.removeEventListener(MouseEvent.MOUSE_MOVE, detectDirection_mouseMoveHandler_Y);				stage.removeEventListener(Event.ENTER_FRAME, drag_mouseUpHandler_H);				stage.removeEventListener(MouseEvent.MOUSE_UP, drag_mouseUpHandler_Y);			}						isTweening = false;									if (maxScroll > 0)			{				var elapsedMiliseconds:Number = getTimer() - previousDragTime;								var pixelsPerMillisecond:Number = deltaMouseY / elapsedMiliseconds;				targetScrollY = Math.round( -pixelsPerMillisecond * MAX_PIXEL_MOVE + scrollY);												//targetScrollY = targetScrollY > height * .5?height * .5:targetScrollY;				if (targetScrollY >= 0) // Scrolling up.					targetScrollY = Math.min(maxScroll, targetScrollY);				else			  // Scrolling down.					targetScrollY = Math.max(targetScrollY, 0);								//trace(targetScrollY);								targetScrollY = Math.round(targetScrollY);												if (targetScrollY != scrollY)				{					doTween(targetScrollY);				}				else				{					// No flick so fade out scrollIndicator immediately.					addEventListener(Event.ENTER_FRAME, scrollIndicatorFade_enterFrameHandler);					dispatchEvent(new ScrollEvent(ScrollEvent.COMPLETE));					/*if (isDragging)						dispatchEvent(new TweenEvent(TweenEvent.TWEEN_COMPLETE));*/				}			}		}		/**		 * The amount to tween is the amount itemContainer.scrollRect.y will change.		 */		private function doTween(value:Number):void		{			targetScrollY = Math.round(value);						startScrollY = scrollY;			totalScrollY = targetScrollY - startScrollY;						tweenCurrentCount = 0;			tweenTotalCount = Math.round(ANIMATION_DURATION * stage.frameRate);			stage.addEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_Y);						isTweening = true;		}				private function detectDirection_mouseMoveHandler_Y(e:Event):void		{			//trace("H",maxScroll,Math.abs(mouseYDown - root.mouseY),START_TO_DRAG_THRESHOLD);			if (maxScroll > 0 && Math.abs(mouseYDown - root.mouseY) > START_TO_DRAG_THRESHOLD)			{  				viewContainer.mouseChildren = viewContainer.mouseEnabled = false;												isDragging = true;								stage.removeEventListener(MouseEvent.MOUSE_MOVE, detectDirection_mouseMoveHandler_Y);				stage.addEventListener(Event.ENTER_FRAME, drag_mouseUpHandler_H);								//dispatchEvent(new ScrollEvent(ScrollEvent.START_SCROLL, false, false, mouseYDown > root.mouseY ? ScrollEvent.DIRECTION_UP : ScrollEvent.DIRECTION_DOWN));			}		}						/**		 * 影藏滚动条		 */		private function scrollIndicatorFade_enterFrameHandler(e:Event):void		{			scrollIndicator.alpha -= scrollIndicatorAlphaDelta;			if (scrollIndicator.alpha <= 0) {				removeEventListener(Event.ENTER_FRAME, scrollIndicatorFade_enterFrameHandler);				viewContainer.mouseChildren = viewContainer.mouseEnabled = true;								this.dispatchEvent(new ScrollEvent(ScrollEvent.SCROLLBARCOMPLETE));							}		}				private function set scrollIndicatorVisible(value:Boolean):void		{			if (scrollIndicator)			{				removeEventListener(Event.ENTER_FRAME, scrollIndicatorFade_enterFrameHandler);				scrollIndicator.alpha = value ? 1 : 0;			}		}				private function drag_mouseUpHandler_H(e:Event):void		{			if(!MWHScrollBarBOOL)e.stopImmediatePropagation();			if (stage)			{				var newY:Number = beginDragScrollY + (mouseYDown - root.mouseY);				scrollY = newY;				//trace(scrollY);				scrollY = scrollY < -(height * .5)?-(height * .5):scrollY > maxScroll+height * .5?maxScroll+height * .5:scrollY;				//trace(scrollY);				enterFrameIndex += 1;							if (enterFrameIndex % NUM_FRAMES_TO_MEASURE_SPEED)				{					deltaMouseY = root.mouseY - previousDragMouseY;					previousDragTime = getTimer();					previousDragMouseY = root.mouseY;				}								updateScrollIndicator();								scrollIndicatorVisible = true;			}		}		private function updateScrollIndicator():void		{						var delta:Number = scrollY / maxScroll;			var newHeight:Number;						if (delta < 0)			{				scrollIndicator.y = Math.round(scrollIndicatorTopPadding);								newHeight = scrollY + scrollIndicatorHeight;				newHeight = Math.max(MIN_SCROLL_INDICATOR_HEIGHT, newHeight);				scrollIndicator.height = Math.round(newHeight);			}			else if (delta < 1)			{				if (scrollIndicator.height != scrollIndicatorHeight)					scrollIndicator.height = Math.round(scrollIndicatorHeight);								var newY:Number = Math.round(delta * totalScrollAmount);				newY = Math.min(_height - scrollIndicatorHeight - scrollIndicatorBottomPadding, newY);				scrollIndicator.y = Math.round(newY + scrollIndicatorTopPadding);			}			else	// User dragged above the bottom edge.			{				// Shrink scrollIndicator.height by the amount a user has scrolled above the bottom edge.				newHeight = scrollIndicatorHeight - (scrollY - maxScroll);				newHeight = Math.max(MIN_SCROLL_INDICATOR_HEIGHT, newHeight);				scrollIndicator.height = Math.round(newHeight);				scrollIndicator.y = Math.round(_height - newHeight - scrollIndicatorBottomPadding);			}						this.dispatchEvent(new ScrollEvent(ScrollEvent.SCROLLBARUPDATE));		}				///////////////////		override public function removeAt():void 		{			if (stage)			{				stage.removeEventListener(MouseEvent.MOUSE_MOVE, detectDirection_mouseMoveHandler_Y);				stage.removeEventListener(Event.ENTER_FRAME, drag_mouseUpHandler_H);				stage.removeEventListener(MouseEvent.MOUSE_UP, drag_mouseUpHandler_Y);				stage.removeEventListener(Event.ENTER_FRAME, tween_enterFrameHandler_Y);				removeEventListener(Event.ENTER_FRAME, scrollIndicatorFade_enterFrameHandler);			}			super.removeAt();					}			}}